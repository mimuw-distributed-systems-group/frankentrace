# How LSU tracing works

We use DWT and ITM to generate traces of Load-Store Unit transfers (address, data, PC).

Out of the box, DWT/ITM allows:
- for each of four comparators:
- compare data address (with masked up to 16 LSB),
- generate event: trigger ETM, generate debug event, send ITM event:
- ITM may output: 16LSB of the address, data with direction, PC and a timestamp.

In this case, we start the trace very early by registering a hook in the Reset interrupt handler.
For more information about tracing see `TPIU.md` and [ARM-ARM] C1.8.1 The DWT comparators.

The main limiting factor is TPIU throughput: it may be set up as UART (8/10) with baudrate = CPU_CLK.
A PC packet takes 5 bytes, timestamp 1-5 bytes.
48MHz UART is not realistic (due to hysteresis), and my desk OSC can sample only on 24MHz, and 3 samples/bit are
minimum for UART decoding -> therefore we have a limit of 8-12Mbaud. That is ca. a 8byte packet each 500 cycles.
The ITM has a very small buffer (order of 1-2 packets) and sends overflow messages.

Ultimately, we have to overcome two issues:
1. We cannot trace all the requests at once - since we can cover only up to 4 x 16 MSB ranges.
2. We are unable to sustain any tight loop of LSU instructions (e.g. 3 loads in a row).

## Overcoming range limit

We employ a similar trick to PC tracing: we're going to run the binary multiple times with various traced ranges.
The basic mechanism is based on a register doing system-wide reset, which retains some memory.
In our case, SRAM is retained and we use a non-initializing region to store data across reboots.
The scheme works as follows:

On reboot in ResetISR:
1. Is it cold reboot (pin reset, power on)? If so initialize retained memory in SRAM to start tracing.
2. Check consistency of our retained metadata.
3. If we're done with the tracing (`END_MAGIC`), just proceed to normal boot.
4. Otherwise, setup tracing for the current iteration (phase) and configure the next iteration.
5. Output some tracing metadata on ITM software stimuli for reference during analysis.
6. Proceed with a normal boot.

At the end of the traced region, a callback does:
1. Disable tracing (so not to spam with SYNC packets). This makes it easier to setup a trigger on an oscilloscope.
2. If we are in a tracing phase: wait for ITM to flush and trigger system reset.

Each reboot takes ~1ms.
If not for the second issue, such traces would be very easy to reconstruct from ITM packet timestamps.

## Overcoming throughput limit

Here we cannot simply employ the previous trick, as there is no option to generate packets only exactly each N-th event.

The first step is to further split the logs from each run into 3 separate traces of: address, data and PC.
Unfortunately, it is still not enough, and we overflow the ITM buffer.
Fortunately, the ITM lets us know about it: we know our scheme is working if we no longer receive overflow indicators.

One approach is to slow down the CPU clock. But we may only divide the clock by 2 into 24MHz. But we cannot generate packets more often than 100KHz.

What we do instead is to accompany each DWT triggered ITM event with triggering a Debug event, thus raising DebugMonitor exception (aka DebugFault).
In the exception we just spin in place for ~1000 cycles.
This makes our trace no longer non-invasive: timing-critical code may change behavior. E.g., a loop waiting for sth to finish may run just once.
Moreover, this means that the produced timestamps are no longer straightforwardly comparable between tracing phases.

There were still a few overflows remaining: generated by critical-section code with disabled interrupts or inside handlers (thus no debug event).
See the algorithm `DerivedLateArrival()` in [ARM-ARM] B1.5.11 "Exceptions on exception entry" for reference.
`ExecutionPriority()` is useful as well.

**Handling exceptions**: we just attempt to lower the priority of all interrupts below that of DebugMonitor.
Essentially, everything greater than 0 (default) works for us. And let's hope the software won't reset priorities back to 0.

**Handling critical-sections** (aka `atomic`): it is typically implemented with setting `PRIMASK=1`, thus elevating current priority to 0.
It is done with either `cpsie i` or `msr/mrs PRIMASK` instructions.
Currently, we patch the NesC `atomic` to use `BASEPRI=1` instead of `PRIMASK`. 

```diff
diff --git a/nesc/whip6/platforms/parts/mcu/cc26xx/Makefile.main b/nesc/whip6/platforms/pa>
index 4b51459..1d532ba 100644
--- a/nesc/whip6/platforms/parts/mcu/cc26xx/Makefile.main
+++ b/nesc/whip6/platforms/parts/mcu/cc26xx/Makefile.main
@@ -97,6 +100,7 @@ $(TARGET).nobl.elf: $(OBJS)
 
 $(TARGET).workingcopy.o: $(TARGET).workingcopy.c
        grep -v -E '^#( |line)' $(TARGET).workingcopy.c > x.c
+       sed -E '/(msr)|(mrs)/ s/primask/basepri/' -i x.c
+       sed -E '/^\s*PRCMSleep\(\);\s*$$/ i NOROM_CPUdelay(128);' -i x.c
        mv -f x.c $(TARGET).workingcopy.c
        @echo "Compiling $(TARGET).workingcopy.c..."
        @$(CC) $(CFLAGS) -c $< -o $@

```

With the above lowering of priorities, only System exceptions may interrupt the code (that is MemMenage, BusFault, UsageFault, SVCall, PendSV -- but also SysTick).
See [TI-TRM] 4.1.2.
**TODO: Lower SysTick priority below 0!**
Note: we added a delay before invocation of `wfi` to let ITM drain out.

There may be remaining driverlib code executing in critical sections, but this needs more research. E.g. during `OSCHF_AttemptToSwitchToXosc` code cannot be run from Flash.

### New issues: invasiveness
The executed code would probably not touch different addresses whenever executed in interruptions from DebugMonitor or not.
But now we need to restore a trace from partial information. What is more, the distortion of timestamps depends on the traced address ranges.
In order to have any inter-range cross-reference we run the tracing for *pairs* of ranges.
For example, when we want to trace ranges A, B, and C, we trace `(A, B), (A, C), (B, C)`.

### Handling sleeps
The system works OK with sleeping. There is just one issue, when we enter DebugMonitor after writing to PDCTL1::CPU_ON:
> CPU_ON RW 0: Causes a power down of the CPU power domain when system CPU indicates it is idle. 

But the TPIU breaks before going to sleep (executing `wfi`). Therefore, in the logs there might be missing DebugMonitor exit events.

# Parsing the trace

Read `TPIU.md` how the tracing interface works. Save a capture in `sigrok` and run something alike to:

```shell
sigrok-cli -i data_trace_concat.srzip -P uart:rx=D0:baudrate=8000000,arm_itm3 -B arm_itm3=pkg_csv |  pd  -o lsu_trace_concat.pkl

python host/parse_lsu_trace.py lsu_trace_concat.pkl 
```

Some files will be placed beside the input. `lsu_trace_wide.pkl` has aggregated data from phases for each of the traced pairs.
